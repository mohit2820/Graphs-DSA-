// finding the acutal path 
import java.util.*;

public class Solution {

	public static LinkedList<Integer> shortestPath(int[][] edges, int n, int m, int src, int t) {
		
		ArrayList<ArrayList<Integer>> adj = new ArrayList<>();

		// Adjacency Matrix Given Hai 
		// 1 - Based Indexing 
		//     1 2 <- Index 
		// 1 | 1 4   (Index - 1 (Vertex 1) , Index - 2 (Vertex 2))
		// 2 | 1 2   edges[1][1] -> Vertex 1 , edges[1][2] -> Vertex 2	
		// 3 | 2 3  
		// 4 | 3 4

		// adj[1] = [4, 2]
		// adj[2] = [1, 3]
		// adj[3] = [2, 4]
		// adj[4] = [1, 3]

		for(int i=0; i<n; i++) adj.add(new ArrayList<>());

		for(int j=0; j<m; j++){
			// make it 0 - based 
			int u = edges[j][0] - 1;
			int v = edges[j][1] - 1;

			adj.get(u).add(v);
			adj.get(v).add(u);
		}

		Queue<Integer> q = new LinkedList<>();
		int[] parent = new int[n];
		boolean[] visited = new boolean[n];

		// 1 - based hai 
		src--;
		t--;

		q.add(src);
		visited[src] = true;
		parent[src] = -1; // parent of source node = -1

		while(!q.isEmpty()){

			int top = q.poll();

			for(int j=0; j<adj.get(top).size(); j++){

				int current = adj.get(top).get(j);

				if(visited[current]) continue;
				
				visited[current] = true;
				q.add(current);
				parent[current] = top;
				
			}
		}

		LinkedList<Integer> path = new LinkedList<>(); 


		while(t!=-1){
			// make it 1 - based again
			path.addFirst(t+1);
			t = parent[t];
		}

		return path;
	}

}
