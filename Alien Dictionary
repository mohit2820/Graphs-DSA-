// Link : https://www.geeksforgeeks.org/problems/alien-dictionary/1

class Solution {
    public String findOrder(String[] words) {
        
        // ğŸ§º not a optimal way but , thik thak code hai 
        // ğŸ§  phle set mai sare unique character dalo 
        Set<Character> set = new HashSet<>();
        
        // ğŸ“¦ String array ke sare words set mai dal rhe hai 
        for(String word : words){
            for(char c : word.toCharArray()) set.add(c);
        }
        
        int K = 26; // ğŸ”¤ K -> Total unique character ie. total alphabets 
        
        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();
        
        // ğŸ§± initialize with empty array list 
        for(int i=0; i<K; i++) adj.add(new ArrayList<>());
        
        // ğŸ§  adjacency list mai mapping karo (Integer form mai)
        // ğŸ“ we know : ascci value
        // 'a' -> iski decimal value : 97 , 'z' -> 122
        // ğŸ“œ question mai given hai : words[i] consists only of lowercase English letters.
        
        // ğŸ§ª Test Case - 1 
        // ğŸ§© agar words hai ["baa", "abcd", "abca", "cab", "cad"]
        // âœ… b -> a (b phle ayega a se)
        // âœ… abcd | abca (abc same hai) so d -> a (d phle ayega a se)
        // âœ… abca | cab  , a -> c (a phle ayega c se)
        // âœ… cab | cad  (ca prefix same hai dono mai) b -> d (b phle ayega d se)
        
        // ğŸ§ª Test Case -2 (Most Imp.)
        // ğŸ§© words = ["ab", "abc", "bca", "bd", "ce"]
        // âœ… ab | abc  (no mapping) (a dono mai hai , b dono mai sab) 
        // âœ… phle wali choti hai string ab < abc (but valid hai) , it means ab phle ayega abc se just like normal dictionary words
        // âœ… abc | bca  , a -> b 
        // âœ… bca | bd , c -> d
        // âœ… bd | ce , b -> c
        
        // ğŸ§ª Test Case - 3 (Most Imp.)
        // ğŸ§© words = ["xylophone", "xyl", "apple", "ap", "banana"]
        // âŒ agar khi bhi phli string badhi ho dusri string se 
        // âŒ eg. xylophone || xvl  (x same , y same , l same) , we know xyl < xylophone
        // âŒ xyl phle ana chiye tha (acc. to dictionary rule)
        // âŒ abhi first word mai "ophone" part ham match hi ni kara sakte hai niche wali to choti hai puri compare ho chuki hai 
        // âŒ so yeh ek invalid order mai 
        // ğŸ“œ question mai given hai : However, if the given arrangement of words is inconsistent with any possible letter ordering, return an empty string ("").
        // ğŸš« baki check hi mat karo seedha return karo "" (not valid , contradiction agya)
        
        // ğŸ“Œ acc. to question TestCase -1 & 2  are valid , now let's code 
        
        int n = words.length;
        int[] inDegree = new int[K];  // ğŸ“Š Khan's Algo 
        // ğŸ§  K -> hame K ka exact value nhi pata or letter ka order bhi nhi pata 
        // â“ sequential nhi honge like from a , b , c it can be p , q ,r or x , y ,z 
        // ğŸ“Œ K is taken as 26 
        
        for(int i=0; i<n-1; i++){
            
            String word1 = words[i];
            String word2 = words[i+1]; 
            // ğŸ§  ham i or i+1 access kar rhe hai jab i = n-1 hoga tab i or i+1 access hoga ie. why ham loop i<n-1 tak chala rhe hai 
            // ğŸ›¡ï¸ when i = n-2 which is < n-1 so word1[n-2] , word2[n-2+1] -> word2[n-1] , invalid access se bach rhe hai 
            
            int p = 0;
            int r = 0;
            // ğŸ” for string comparsion 
            
            while(p<word1.length() && r<word2.length() && word1.charAt(p)==word2.charAt(r)){
                p++;
                r++;
            }
            
            // âŒ Test Case -3 (Invalid)
            // âŒ abc 
            // âŒ ab    (contradiction)
            if(p<word1.length() && r==word2.length()) return "";
            
            else if(p<word1.length() && r<word2.length()){
                
                int u = word1.charAt(p) - 'a';  
                // ğŸ§® eg .  e - a (asscii value = 101 - 97 = 4 ) 
                // ğŸ”  a b c ...z (0 - a , 1 - b , 2 -c , 3 - d , 4 -e , 5 -f .... z - 25)
                int v = word2.charAt(r) - 'a';
                
                adj.get(u).add(v);  // ğŸ”— DAG 
                inDegree[v]++;
            }
        }
        
        // ğŸšª Queue for topological sort
        Queue<Integer> q = new LinkedList<>();
        for(int i=0; i<K; i++){
            if(inDegree[i]==0 && set.contains( (char) (i + 'a'))) q.add(i);
        }
        
        String ans = "";
        while(!q.isEmpty()){
            
            int top = q.poll();
            ans += (char) ('a' + top); // ğŸ”¡ type case back to char
            // ğŸ§­ toplogical sort order chiye hamko 
            
            for(int i=0; i<adj.get(top).size(); i++){
                int current = adj.get(top).get(i);
                inDegree[current]--;
                if(inDegree[current]==0) q.add(current); 
            }
        }
        
        // ğŸ” cycle detection 
        return (ans.length()==set.size()) ? ans : "";
    }
}
